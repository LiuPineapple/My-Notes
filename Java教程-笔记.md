# Java教程-笔记

## 1 Java快速入门

### 1.1 Java简介

#### 1.1.1 安装JDK

1. 设置JAVA_HOME系统环境变量
2. 在系统环境变量Path中添加%JAVA_HOME%\bin\
3. 需要注意的是，现在安装JDK，安装程序会自动创建C:\Program Files\Common Files\Oracle\Java\javapath目录，并在里面存放一系列Java的exe程序，并把这一目录添加到Path最开头去（有的版本会把exe程序放到C:\Windows\System32中去，且C:\Windows\System32本就在Path环境变量中）。因此，我们在cmd命令行中运行java -version其实是调用这一目录下的exe而没有用到上述JAVA_HOME设置。如果想要用到上述JAVA_HOME设置，可以把%JAVA_HOME%\bin\移动到C:\Program Files\Common Files\Oracle\Java\javapath前面去。
4. 如果安装两个JDK版本可以设置两个系统环境变量，比如一个为JAVA_HOME_15另一个为JAVA_HOME_1.8指向各自的安装目录，那么只要在Path中将%JAVA_HOME%\bin\移动到C:\Program Files\Common Files\Oracle\Java\javapath前面，并改变%JAVA_HOME%的值，即可以实现版本切换
5. 上面第4条是在命令行中实现版本切换，如果要在ide比如eclipse中实现版本切换，只需要在Window-Preferences-Java-Installed JREs中添加并选择相应版本的jre，同时在Window-Preferences-Java-Compiler中将“Compiler compliance level”设置为相应版本号，即完成了对当前工作空间的版本切换。

### 1.2 Java程序基础

#### 1.2.1 Java程序基本结构

1. 各种命名的强制规范都是英文字母开头，后接字母，数字和下划线的组合
2. 类名建议规范为每个单词的首字母大写，遇到缩写要全大写。
3. 方法名的建议规范时第一个单词全小写，剩下的单词首字母大写。遇到缩写要全大写。
4. 包名的建议规范是全小写
5. JAVA关键字一般都是全小写

## 2 面向对象编程

### 2.1 面向对象基础

#### 2.1.1 方法

1. 在类定义内声明变量，那么这个变量就成为了属性/字段。属性可以在声明的时候直接赋值
2. 在声明变量和方法的时候，在类型前面可以加修饰符表示权限，如public static
3. 调用方法时，必须严格按照定义的类型和顺序传入
4. 基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。
5. java中的修饰符分类:
   - 权限修饰符: private, protected, public，默认不写(即default)
   - 状态修饰符: static, final
   - 抽象修饰符: abstract

#### 2.1.2 构造方法

1. 在java中，属性总要在类中显式的声明，就像在java中变量总要显示声明一样，即使我有给属性赋值的构造方法，也要在构造方法之前先声明，这里声明的是实例属性。如果要声明类属性，需要加关键字static。对比python，python中的实例属性不需要提前声明，可以直接写在构造函数中，如果提前声明了，那么就成为了类属性。在两种语言中，所有属性/变量都可以在声明的时候直接赋值
2. 构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有`void`），调用构造方法，必须用`new`操作符，同时构造方法前面要有public这种表示权限的修饰符。
3. 如果不自己写构造方法，那么编译器会自动给补上空构造方法（其实在空构造方法中还会再补上一个super()，即调用父类构造方法），如果自己写了，那么编译器就不会补了。
4. 实例化的时候先初始化属性，再初始化构造方法，所以如果在声明属性的时候赋值了，构造方法中又赋值了，那么最后会以构造法方法中为准，因为其后执行。
5. 没有在构造方法中初始化字段时，引用类型的字段默认是`null`，数值类型的字段用默认值，`int`类型默认值是`0`，布尔类型默认值是`false`
6. 可以定义多个构造方法，在通过`new`操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分。
7. 作用域越小的局部变量，在它所在作用域中就优先级越高，所以在构造方法中，如果字段名和形参名重名，形参名优先级更高，字段名前面要加this.防止歧义。

#### 2.1.3 方法重载

1. 方法重载(overload)，返回值和函数名相同，但参数不同，编译器通过方法的参数数量、位置和类型自动区分调用哪个方法。
2. 2.1.2节中的定义多个构造函数就是方法重载。

#### 2.1.4 继承

1. 在Java中，没有明确写`extends`的类，编译器会自动加上`extends Object`，同时，所有继承树向上追溯都可以追溯到Object类。
2. Java只允许一个class继承自一个类，但一个类可以被多个类继承。因此，一个类有且仅有一个父类。只有`Object`特殊，它没有父类。
3. 在java中，子类继承父类除了构造函数外的所有属性和方法，因此严禁定义与父类重名的字段，但可以覆写(override)父类方法。
4. 但是一些private的属性和方法无法访问（这里存疑，是继承所有但private无法访问，还是继承非private呢？但是这个疑问并不影响使用）注意，这里的无法访问是说，即使使用类内访问也无法访问，类内访问可以访问子类自己的private但是不能访问父类的private，如果想要访问父类的private，需要使用继承下来的父类的public方法。
5. 子类不会继承父类的构造方法。如果不自己定义构造方法，那么编译器会补一个空构造方法，然后再空构造方法中补一个super()即调用父类构造方法。如果是自己定义构造方法的话，如果不显示调用父类构造方法，那么编译器也会给你自动加super()，显式调用则不会加。因此如果自己定义子类构造方法，第一行必须是父类的构造函数，如果你不写，编译器也会给你自动加super()，这时候如果父类没有空构造方法，就会报错。总而言之，对于一个类来说，第一步，如果没有自己定义构造方法，编译器会补一个空构造方法；第二步，对于所有构造方法（包括上一步编译器自己补的空构造方法）来说，如果没有在第一行调用父类构造方法，编译器会补一个super()。
6. 向上转型(upcasting)一定是成功的，但向下转型(downcasting)不一定能成功

#### 2.1.X 权限修饰符的作用

1. 见https://blog.csdn.net/aimeimeits/article/details/54136219
2. java当中的权限修饰符分为两级，一级是修饰类的，一级是修饰成员（即属性和方法）的
3. 第一级修饰类的只有public和不写，即没有显式修饰符（即package-private或者说default）两种，代表包外是否可见
4. 第二类修饰符有四种，按照权限由大到小分为public>protected>default(即不写)>private，权限关系见上面的博文
5. 当我们在java程序中调用某个类及其成员，整个判断过程如下：
   - 如果类名简写，即前面没有包名，会去当前包，import的类以及java.lang中去找这个类的完整名，即包名.类名，如果使用完整类名，则已经得到完整类名直接进行下一步
   - 在classpath中找这个类的路径，eclipse默认是bin以及import类的路径以及java核心类路径（这里面存在查找顺序与逻辑短路），其中import类的路径会在eclipse的library中查找，library中存放的是类的文件路径。
   - 如果这个类是public类，则直接跳转下一步。如果这个类是package-private，且与本程序在一个包中，那么跳转下一步。如果这个类是package-private，且与本程序不在一个包中，那么此类包外不可见，无法调用。
   - 到这一步，这个类是可用的，但类内成员是否可用要根据第二类修饰符的权限进行判别，见上面博客。
   - 继承之后，如果子类对某一成员依旧具有访问权限，那么我们就认为这个成员的权限修饰符和父类一样，如果子类无法访问这个成员，那么我们就可以直接当作这一成员不存在了。
   - 具体还是存在很多细节，比如包权限，子类在包外，子类的子类回到包内，这种情况我的理解是，不考虑中间的子类，直接把孙类和父类放在一起看，反正孙类也是父类的子类，而且父类的方法它全部继承了，涉及权限问题就按孙类是父类的子类然后按表来。这只是猜测，准不准我也不知道。

#### 2.1.5 多态

1. 重载(overload)是只函数名，返回类型相同，但参数不同，本质是两个不同的函数，作用是方便多样化调用，每一个重载的函数都有被调用的可能。覆写/重写(override)是指函数名，返回类型，参数都相同。一般用在子类上，重写父类方法，引出多态。
2. 方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。
3. 子类覆写父类方法，在调用的时候无论变量类型是子类还是父类，只要指向的是子类实例，则调用子类覆写后的方法。因为ava的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。
4. java中的多态即把子类实例传入父类变量，从而只用对父类变量编写程序，具体运行效果依赖传入的子类实例，因为子类覆写了父类方法。子类覆写父类方法是多态的关键。
5. final修饰变量（包括类中的属性），则无法被重新赋值，修饰方法，则无法被覆写，修饰类，则这个类无法被继承，见：https://www.cnblogs.com/tanshaoshenghao/p/10908771.html



#### 2.1.8 静态字段和静态方法

1. 静态字段和方法的修饰符为static，所谓静态字段和静态方法即为类字段和类方法。
2. 通过实例可以访问和修改静态字段，可以调用静态方法，但本质都是编译器先把实例名转换成为类名再调用。
3. 静态方法类似于其他语言中的函数，不属于实例，因此内部无法调用this变量，也无法访问实例字段，只能访问静态字段

### 2.2 异常处理

### 2.2.1 Java的异常

1. 异常会出现在两个时候，编译的时候和运行的时候。
2. 必须捕获的异常是指在调用时必须手动用try catch捕获，或者向上一层抛出（即使运行不会出错），如果不捕获/向上一层抛出，那么即使整个运行本身不会出错也会编译失败；不必须捕获的，不捕获也不会编译失败，可以看实际情况确定是否捕获
3. try catch语句使得当发生预期异常的时候程序不会失败退出，而是安装预先给的方案运行下去
4. 在方法定义时可以在参数括号后面，函数体花括号前面使用`throws Xxx(异常类型)`表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。
5. 在调用方法的方法中也可以用`throws Xxx(异常类型)`，作用是异常可以在这一层被检查但不在这一层被捕获，而是抛到上一层，由上一层负责捕获。即对于一个Checked Exception来说， must be caught or declared to be thrown。由此可见，`main()`方法也是最后捕获`Exception`的机会。
6. 可以直接把`main()`方法定义为`throws Exception`，在内部就无需捕获了，异常会被直接抛给调用者/程序员。代价就是一旦发生异常，程序会立刻退出。也就是说在这个时候，编译的异常规范被满足，编译时不会出错；但运行的时候一旦出错，没有try catch的异常处理方案，会直接报错退出。

#### 2.2.2 捕获异常

