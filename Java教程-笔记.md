# Java教程-笔记

## 1 Java快速入门

### 1.1 Java简介

#### 1.1.1 安装JDK

1. 设置JAVA_HOME系统环境变量
2. 在系统环境变量Path中添加%JAVA_HOME%\bin\
3. 需要注意的是，现在安装JDK，安装程序会自动创建C:\Program Files\Common Files\Oracle\Java\javapath目录，并在里面存放一系列Java的exe程序，并把这一目录添加到Path最开头去（有的版本会把exe程序放到C:\Windows\System32中去，且C:\Windows\System32本就在Path环境变量中）。因此，我们在cmd命令行中运行java -version其实是调用这一目录下的exe而没有用到上述JAVA_HOME设置。如果想要用到上述JAVA_HOME设置，可以把%JAVA_HOME%\bin\移动到C:\Program Files\Common Files\Oracle\Java\javapath前面去。
4. 如果安装两个JDK版本可以设置两个系统环境变量，比如一个为JAVA_HOME_15另一个为JAVA_HOME_1.8指向各自的安装目录，那么只要在Path中将%JAVA_HOME%\bin\移动到C:\Program Files\Common Files\Oracle\Java\javapath前面，并改变%JAVA_HOME%的值，即可以实现版本切换
5. 上面第4条是在命令行中实现版本切换，如果要在ide比如eclipse中实现版本切换，只需要在Window-Preferences-Java-Installed JREs中添加并选择相应版本的jre，同时在Window-Preferences-Java-Compiler中将“Compiler compliance level”设置为相应版本号，即完成了对当前工作空间的版本切换。

### 1.2 Java程序基础

#### 1.2.1 Java程序基本结构

1. 各种命名的强制规范都是英文字母开头，后接字母，数字和下划线的组合
2. 类名建议规范为每个单词的首字母大写，遇到缩写要全大写。
3. 方法名的建议规范时第一个单词全小写，剩下的单词首字母大写。遇到缩写要全大写。
4. 包名的建议规范是全小写
5. JAVA关键字/数据类型一般都是全小写
6. Java入口程序规定的方法必须是静态方法，方法名必须为`main`，括号内的参数必须是String数组。
7. Java的每一行语句必须以分号结束

#### 1.2.2 变量和数据类型

1. Java只定义了带符号的整型，因此，最高位的bit表示符号位
2. 在Java语言当中，表示数字，没有前缀表示十进制，0b前缀表示二进制，0前缀表示八进制(python当中是0o前缀），0x前缀表示16进制，0e前缀表示科学计数法。同一个数的不同进制的表示是完全相同的，例如`15`=`0xf`＝`0b1111`
3. 直接输入的数值，对于整形来说，如果是long，在数的最后要加L，否则默认会存储为int，比如3L就会当成long，内部存储就是8个字节，不加L就会当成int，内部存储就是4个字节。对于浮点数来说，如果是float，要在数的最后加f，否则默认会存储为double类型。如果一个数是整数，但我们想让他存储为浮点数类型，就在后面加.0，比如5.0（python当中可以直接在整数后面加点，即5.在内部会以浮点数来存储）
4. Java语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要1 bit，但是通常JVM内部会把`boolean`表示为4字节整数。Java是true,false，python是True，Fasle
5. 一个char，用单引号括起来，表示一个unicode字符，占据两个字节。
6. 常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。根据习惯，常量名通常全部大写（建议规范）
7. 在语句块中定义的变量，它有一个作用域，就是从定义处开始，到语句块结束时结束。
8. 引用类型内部存储的是“地址”，指向某个对象在内存的位置

#### 1.2.4 浮点数运算

1. 浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算。
2. 由于很多十进制的小数转换为二进制是无限循环的，因此很多小数浮点数无法精确表示，浮点数运算也就存在误差。由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数
3. 如果一个数没有小数点后的位，但我们想让它是浮点数，就用.0，比如5.0

#### 1.2.5 布尔运算

1. 布尔运算包括比较运算和逻辑运算，前者结果是boolean，后者参与运算的是boolean
2. !=为比较运算符，!为逻辑运算的非，相当于python中的not
3. 布尔运算的一个重要特点是短路运算。如果一个布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果。
4. 三元运算符是通过问号和冒号

#### 1.2.6 字符和字符串

1. 一个char保存一个unicode字符，可以是英文，可以是中文，用单引号括起来。有两种表示方法，一个是单引号括起来一个字符，另一个是单引号括起来'\\uxxxx'的形势，其中xxxx为4个十六进制unicode编码。
2. 想要得到一个char的unicode编码直接将其赋值给int类型的变量即可。
3. 一个字符串可以存储0个到任意个字符，因此存在空字符串
4. 在字符串中，一个双引号内，可以混用字符和\u的unicode编码。String s = "ABC\n\u4e2d\u6587"; // 包含6个字符: A, B, C, 换行符, 中, 文
5. 如果用`+`连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接
6. 多行字符串使用三个双引号，好处是不用写那么多的换行符
7. Java中的字符串类型是不可变的
8. 引用类型的变量可以指向一个空值`null`，它表示不存在，即该变量不指向任何对象。如果只声明不赋值一个引用类型的变量，那么这边变量也是`null`
9. 注意要区分空值`null`和空字符串`""`，空字符串是一个有效的字符串对象，它不等于`null`

#### 1.2.7 数组类型

1. Java数组三种建立方式
2. 数组创建后所有元素初始化为默认值
3. 数组创建后长度不能更改
4. 方括号可以索引数组元素，索引从0开始，方括号也可以修改数组元素
5. 可以用`数组变量.length`获取数组大小
6. 数组中的元素可以是基本类型，可以是引用类型，还可以是自己定义的类型。

### 1.3 流程控制

#### 1.3.1 输入和输出

System.out.println()及其他一系列方法，输入不一定是字符串，也可以是int等其他类型，它会自动转化为字符串然后输出。

#### 1.3.2 if判断

if判断三种形势：

1. 只有if，则if后面条件为true，执行if后面代码块，为false则不执行，跳到if代码块后面执行
2. if...else...，则if后面条件为true，执行if后面代码块，为false则执行else后面代码块
3. if...else if...else if...，按照顺序从上到下判断条件，遇到第一个true的时候执行后面的代码块，其他代码不再执行，即存在逻辑短路。如果全为false，则跳过这一段代码块执行后面的
4. if...else if...else if...else，按照顺序从上到下判断条件，遇到第一个true的时候执行后面的代码块，其他代码不再执行，即存在逻辑短路。如果全为false，则执行else后面代码块
5. 浮点数判断值是否相等用Math.abs(a-b)<0.00001，其他数值类型用==，引用类型用.equals()，引用类型用==的话判断的是是否指向同一对象。我的理解是，==判断的就是值是否相等，但是引用类型内部存储的是内存地址，因此判断地址是否相等本质上判断的是是否指向同一对象。
6. switch旧语法具有穿透效应，不能逻辑短路，如果两个条件相邻且执行同一个语句，第一个条件冒号后面可以不写。switch新语法不具有穿透效应，是逻辑短路的。用->代替:，后面可以跟大括号包起来的代码块，可以用来赋值。在代码块中可以用yield声明返回值。

#### 1.3.6 for循环

由于for循环是先初始化计数器再判断循环条件，因此即使第一次就不满足循环条件，计数器依旧被初始化了。

#### 1.3.7 break和continue

break和continue都是作用于其所在的那一层循环，仅作用于一层。

#### 1.3.8 命令行参数

命令行参数在java程序中以字符串数组的形式存在，但我们在命令行中输入的时候只要字符串,字符串,...这样即可。

## 2 面向对象编程

### 2.1 面向对象基础

#### 2.1.1 方法

1. 在类定义内声明变量，那么这个变量就成为了属性/字段。属性可以在声明的时候直接赋值
2. 在声明变量和方法的时候，在类型前面可以加修饰符表示权限，如public static
3. 方法可以包含0个或任意个参数；调用方法时，参数必须严格按照定义的类型和顺序传入
4. 基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。
5. java中的修饰符分类:
   - 权限修饰符: private, protected, public，默认不写(即default)
   - 状态修饰符: static, final
   - 抽象修饰符: abstract
6. 方法返回值通过`return`语句实现，如果没有返回值，返回类型设置为`void`，可以省略`return`，无论什么时候，遇到`return`则整个方法执行结束，后面的不再执行。

#### 2.1.2 构造方法

1. 在java中，属性总要在类中显式的声明，就像在java中变量总要显式声明一样，即使我有给属性赋值的构造方法，也要在构造方法之前先声明，这里声明的是实例属性。如果要声明类属性，需要加关键字static。对比python，python中的实例属性不需要提前声明，可以直接写在构造函数中，如果提前声明了，那么就成为了类属性。在两种语言中，所有属性/变量都可以在声明的时候直接赋值
2. 构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有`void`），调用构造方法，必须用`new`操作符，同时构造方法前面要有public这种表示权限的修饰符。
3. 如果不自己写构造方法，那么编译器会自动给补上空构造方法（其实在空构造方法中还会再补上一个super()，即调用父类构造方法），如果自己写了，那么编译器就不会补了。
4. 实例化的时候先初始化属性，再初始化构造方法，所以如果在声明属性的时候赋值了，构造方法中又赋值了，那么最后会以构造法方法中为准，因为其后执行。
5. 没有在构造方法中初始化字段时，引用类型的字段默认是`null`，数值类型的字段用默认值，`int`类型默认值是`0`，布尔类型默认值是`false`
6. 可以定义多个构造方法，在通过`new`操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分。本质上是方法重载
7. 作用域越小的局部变量，在它所在作用域中就优先级越高，所以在构造方法中，如果字段名和形参名重名，形参名优先级更高，字段名前面要加this.防止歧义。

#### 2.1.3 方法重载

1. 方法重载(overload)，返回值和函数名相同，但参数不同，编译器通过方法的参数数量、位置和类型自动区分调用哪个方法。
2. 2.1.2节中的定义多个构造函数就是方法重载。

#### 2.1.4 继承

1. 在Java中，没有明确写`extends`的类，编译器会自动加上`extends Object`，同时，所有继承树向上追溯都可以追溯到Object类。
2. Java只允许一个class继承自一个类，但一个类可以被多个类继承。因此，一个类有且仅有一个父类。只有`Object`特殊，它没有父类。
3. 在java中，子类继承父类除了构造函数外的所有属性和方法，因此严禁定义与父类重名的字段，但可以覆写(override)父类方法。
4. 但是一些private的属性和方法无法访问（这里存疑，是继承所有但private无法访问，还是继承非private呢？但是这个疑问并不影响使用）注意，这里的无法访问是说，即使使用类内访问也无法访问，类内访问可以访问子类自己的private但是不能访问父类的private，如果想要访问父类的private，需要使用继承下来的父类的public方法。
5. protected是可以类外访问的，同包类和外包子类都可以类外访问。
6. 子类不会继承父类的构造方法。如果不自己定义构造方法，那么编译器会补一个空构造方法，然后再空构造方法中补一个super()即调用父类构造方法。如果是自己定义构造方法的话，如果不显示调用父类构造方法，那么编译器也会给你自动加super()，显式调用则不会加。因此如果自己定义子类构造方法，第一行必须是父类的构造函数，如果你不写，编译器也会给你自动加super()，这时候如果父类没有空构造方法，就会报错。总而言之，对于一个类来说，第一步，如果没有自己定义构造方法，编译器会补一个空构造方法；第二步，对于所有构造方法（包括上一步编译器自己补的空构造方法）来说，如果没有在第一行调用父类构造方法，编译器会补一个super()。
7. 向上转型(upcasting)一定是成功的，但向下转型(downcasting)不一定能成功，为了避免向下转型出错，Java提供了`instanceof`操作符，可以先判断一个实例究竟是不是某种类型，即 变量名 `instanceof` 类名 。
8. `instanceof`实际上判断一个变量所指向的实例（而不是该变量本身）是否是指定类型，或者这个类型的子类。如果一个引用变量为`null`，那么对任何`instanceof`的判断都为`false`。

#### 2.1.5 多态

1. 只有函数三要素（返回值，函数名，参数定义）全相同，但函数实现不同，才叫覆写(override)，如果参数定义不同，其他两个相同，叫重载(overload)。重载(overload)是只函数名，返回类型相同，但参数不同，本质是两个不同的函数，作用是方便多样化调用，每一个重载的函数都有被调用的可能。覆写/重写(override)是指函数名，返回类型，参数都相同。一般用在子类上，重写父类方法，引出多态。
2. 多态的基础是函数覆写和向上转型。即子类覆写父类方法，以父类变量为参数写方法，然后父类变量引用子类实例从而根据传入的子类不同，调用不同的方法。java中的多态即把子类实例传入父类变量，从而只用对父类变量编写程序，具体运行效果依赖传入的子类实例，因为子类覆写了父类方法。子类覆写父类方法是多态的关键。
3. 定义方法的时候，必须实现方法的语句，除非是抽象方法。
4. 如果定义了抽象方法，则这个类必须定义为抽象类，且这个类无法实例化，且这个类的子类必须覆写抽象方法。
5. 子类覆写父类方法，在调用的时候无论变量类型是子类还是父类，只要指向的是子类实例，则调用子类覆写后的方法。因为Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。
6. final修饰变量（包括类中的属性），则无法被重新赋值，修饰方法，则无法被覆写，修饰类，则这个类无法被继承，见：https://www.cnblogs.com/tanshaoshenghao/p/10908771.html

#### 2.1.6 抽象类

1. 定义方法的时候，必须实现方法的语句，除非这个方法是抽象方法abstract，这个时候没有函数体但这个方法定义的最后就要加;
2. 通过`abstract`定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范（返回值类型，方法名，参数定义）；因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。抽象类无法被实例化，存在的作用就是给子类定义规范。
3. 从抽象类继承的子类必须覆写/实现抽象方法，如果不实现抽象方法，编译会报错（有抽象方法但类不是抽象类）。除非则该子类的定义前面加上abstract，这时候子类仍是一个抽象类，无法实例化。即我的理解是，一个类继承一个抽象类有两个选择，第一是这个子类也定义为抽象类，这样不必须覆写父类方法，但是子类同样也无法实例话；二是子类不是抽象类，这时候就必须覆写所有父类中的抽象方法，否则编译器会报错（即有抽象方法但类不是抽象类）。

#### 2.1.7 接口

1. 接口是区分public和package-private的，相关修饰符和类一样写在interface前面。接口定义的所有方法默认都是`public abstract`的，所以这两个修饰符不需要写出来（写不写效果都一样）。
2. default方法介于abstract方法和普通方法之间，可以有函数实现，但由于接口没有字段，因此无法调用字段。
3. 在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个`interface`，如果一个类implements了接口，那么就必须覆写/实现这个接口中的方法
4. 一个`interface`可以继承自另一个`interface`。`interface`继承自`interface`使用`extends`，它相当于扩展了接口的方法。接口继承不用覆写抽象方法，因为子类也是一个接口。

#### 2.1.8 静态方法和静态字段

1. 静态字段和方法的修饰符为static，所谓静态字段和静态方法即为类字段和类方法。
2. 静态方法类似于其他语言中的函数，不属于实例，因此内部无法调用this变量，也无法访问实例字段，只能访问静态字段
3. 接口无法拥有实例字段，但可以拥有类字段
4. 因为`interface`的字段只能是`public static final`类型，所以我们可以把这些修饰符都去掉。
5. 通过实例可以访问和修改静态字段，可以调用静态方法，但本质都是编译器先把实例名转换成为类名再调用。

#### 2.1.9 包

1. 完整的类名应该是包名.类名
2. 包可以具有多层级结构，但结构之间只是在目录上具有层级关系，在逻辑上并不存在父子关系，例如，java.util和java.util.zip是不同的包，两者没有任何继承关系。
3. 所有Java文件对应的目录层次要和包的层次一致。编译后的`.class`文件也需要按照包结构存放。
4. 如果有两个`class`名称相同，例如，`mr.jun.Arrays`和`java.util.Arrays`，那么只能`import`其中一个，另一个必须写完整类名。
5. 由此可以见，java当中import仅仅是起到帮助寻找完整类名的作用，即使一个类不import，只要在代码中使用完整类名，只要它在ide的library中，在运行时的classpath当中，一样可以正常运行（检验过是正确的）。
6. 要注意不要和`java.lang`包的类重名，也不要和JDK常用类重名。

#### 2.1.10 作用域

1. 方法参数也是局部变量
2. 一个`.java`文件只能包含一个`public`类，但可以包含多个非`public`类

#### 2.1.X 权限修饰符的作用

1. 见https://blog.csdn.net/aimeimeits/article/details/54136219
2. java当中的权限修饰符分为两级，一级是修饰类的，一级是修饰成员（即属性和方法）的
3. 第一级修饰类的只有public和不写，即没有显式修饰符（即package-private或者说default）两种，代表包外是否可见
4. 第二类修饰符有四种，按照权限由大到小分为public>protected>default(即不写)>private，权限关系见上面的博文
5. 当我们在java程序中调用某个类及其成员，整个判断过程如下：
   - 如果类名简写，即前面没有包名，会去当前包，import的类以及java.lang中去找这个类的完整名，即包名.类名，如果使用完整类名，则已经得到完整类名直接进行下一步
   - 在classpath中找这个类的路径，IDE(例如eclipse)默认是bin以及import类的路径以及java核心类路径（这里面存在查找顺序与逻辑短路），其中import类的路径会在eclipse的library中查找，library中存放的是类的文件路径。
   - 如果这个类是public类，则直接跳转下一步。如果这个类是package-private，且与本程序在一个包中，那么跳转下一步。如果这个类是package-private，且与本程序不在一个包中，那么此类包外不可见，无法调用。
   - 到这一步，这个类是可用的，但类内成员是否可用要根据第二类修饰符的权限进行判别，见上面博客。
   - 继承之后，如果子类对某一成员依旧具有访问权限，那么我们就认为这个成员的权限修饰符和父类一样，如果子类无法访问这个成员，那么我们就可以直接当作这一成员不存在了。
   - 具体还是存在很多细节，比如包权限，子类在包外，子类的子类回到包内，这种情况我的理解是，不考虑中间的子类，直接把孙类和父类放在一起看，反正孙类也是父类的子类，而且父类的方法它全部继承了，涉及权限问题就按孙类是父类的子类然后按表来。这只是猜测，准不准我也不知道。
6. 我猜并验证，IDE(例如eclipse)是怎么知道Import类的路径的呢，这依赖于library，library中存储了依赖jar包的位置，IDE会在library中查找，找到后放入classpath中，并读取用于补全等其他功能。默认library是JDK安装路径中的那些自带包，我们可以在项目中将我们自己定义的JAR包放在默认library中，这时有两种方式，第一是外部导入，这时候JAR包不在项目中，导入的路径是绝对路径，这导致只能在本机运行；第二是内部导入，即在项目中建立依赖包目录(比如lib)然后将JAR包放入，然后选择内部导入，这时候导入的路径是相对路径，打包的时候会一起打包走，因此换机器也可以跑。当然如果不想每次都导入library，也可以建立一个自己的自定义library，然后在项目中引入，但本质还是刚才那两种方式。

### 2.2 Java核心类

## 3 异常处理

### 3.1 Java的异常

1. 异常会出现在两个时候，编译的时候和运行的时候。
2. 必须处理的异常(checked exception)是指在调用时必须手动用try catch捕获，或者向上一层抛出（即使运行不会出错），如果不捕获/向上一层抛出，那么即使整个运行本身不会出错也会编译失败，这是一个强制规则；即对于一个Checked Exception来说， must be caught or declared to be thrown，要么在这一层捕获处理，要么扔给上一层捕获处理。由此可见，`main()`方法也是最后捕获`Exception`的机会。如果`main()`方法也不捕获，而是选择抛出，那么在内部就无需捕获了，代价就是一旦发生异常，程序会立刻退出。
3. 不必须处理的，不处理也不会编译失败，可以看实际情况确定是否处理，如果不捕获，那么在运行过程中遇到异常会一层层向上抛出（不需要写throw)。
4. 问题：即使在方法中不声明throw遇到错误也会一层层向上抛出，那写的意义何在呢？答案是，在方法定义时在参数括号后面，函数体花括号前面使用`throws Xxx(异常类型)`表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制处理（捕获/向上抛出）这些异常，否则编译器会报错。
5. try catch语句使得当发生预期异常的时候程序不会失败退出，而是按照预先给的方案运行下去，即异常被捕获住了。
6. 在调用方法的方法中也可以用`throws Xxx(异常类型)`，作用是异常可以在这一层被检查但不在这一层被捕获，而是抛到上一层，由上一层负责捕获。
7. 可以直接把`main()`方法定义为`throws Exception`，在内部就无需捕获了，异常会被直接抛给调用者/程序员。代价就是一旦发生异常，程序会立刻退出。也就是说在这个时候，编译的异常规范被满足，编译时不会出错；但运行的时候一旦出错，没有try catch的异常处理方案，会直接报错退出。
8. 所有异常都可以调用`printStackTrace()`方法打印异常栈，这是一个简单有用的快速打印异常的方法。
9. 异常栈要从下往上看，越往下其实是调用的越上层。

### 3.2 捕获异常

1. 多catch语句每个`catch`分别捕获对应的`Exception`及其子类，注意子类也会被捕获。
2. 即无论是catch还是trows，异常处理都可以处理异常类及其子类，而且逻辑短路
3. 多catch语句是逻辑短路的，类似逻辑短路的还有逻辑运算和新式的switch语句
4. 存在多个`catch`的时候，`catch`的顺序非常重要：子类必须写在前面。
5. `finally`语句不是必须的，可写可不写；
6. finally无论有没有异常都会抛出，即如果没有异常，try中的语句执行完毕接着执行finally，如果发生异常，try中发生异常的地方后面的代码就不再执行，跳转到对应的catch去执行，最后执行finally。
7. 如果方法声明了throw异常抛出，那么try后面可以不加catch直接finally，因为这时候异常可以不被捕获而是直接抛出。

### 3.3 抛出异常

1. 用户可以自行定义，当出现某种情况时抛出异常，这时候用throw关键字，一般和if 连在一起用。当抛出异常后，这个语句块后面的代码就不再执行了。注意这里是throw，而在方法定义时定义异常抛出是用throws。
2. 在`catch`中抛出异常，不会影响`finally`的执行。JVM会先执行`finally`，然后抛出异常。
3. `finally`抛出异常后，原来在`catch`中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）。

## 4 反射

### 4.1 Class类

1. 除了`int`等基本类型外，Java的其他类型全部都是`class`（包括`interface`），`class`（包括`interface`）的本质是数据类型（`Type`）
2. `class`是由JVM在执行过程中动态加载的。JVM在第一次读取到一种`class`类型时，将其加载进内存。每加载一种`class`，JVM就为其创建一个`Class`类型的实例，此外，JVM为每一种基本类型如int也创建了`Class`
3. 每一个.class文件被jvm加载后，会在jvm中创建一个类型为Class类型的对象来表示这份字节码，你可以通过类名.class获取这个Class类型的对象，例如String.class，也可以通过类对象.getClass()方法来获取，例如obj.getClass()
4. `Class`类的构造方法是`private`，只有JVM能创建`Class`实例，我们自己的Java程序是无法创建`Class`实例的。
5. 一个`Class`实例包含了该`class`的所有完整信息，因此，如果获取了某个`Class`实例，我们就可以通过这个`Class`实例获取到该实例对应的`class`的所有信息。这种通过`Class`实例获取`class`信息的方法称为反射（Reflection）
6. 一个类可以构造多个实例，但其在JVM中的Class实例是唯一的，即多个类实例的.getClass()方法得到的其实是同一个Class对象
7. 用`instanceof`不但匹配指定类型，还匹配指定类型的子类。而用`==`判断`class`实例可以精确地判断数据类型，但不能作子类型比较。通常情况下，我们应该用`instanceof`判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个`class`的时候，我们才使用`==`判断`class`实例。
8. JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。

## 6 泛型

### 6.1 什么是泛型

1. 泛型就是编写模板代码来适应任意类型；即在编写类的时候用尖括号<>括住大写英文字母，这些大写英文字母在后续可以代表某种类型，由此实现模板的作用
2. 注意泛型的继承关系：可以把`ArrayList<Integer>`向上转型为`List<Integer>`（`T`不能变！），但不能把`ArrayList<Integer>`向上转型为`ArrayList<Number>`（`T`不能变成父类）。即向上转型的两种方法，类的向上转型是可以的，但必须保证泛型中的类相同；类相同，但泛型中的类向上转型，这是不被允许的。

### 6.2 使用泛型

1. 使用泛型时，把泛型参数`<T>`替换为需要的class类型
2. 编译器如果能自动推断出泛型类型，就可以省略后面的泛型类型。
3. 不指定泛型参数类型时，编译器会给出警告，且只能将`<T>`视为`Object`类型；

### 6.3 编写泛型

1. 编写泛型时，需要定义泛型类型`<T>`；
2. 静态方法不能引用泛型类型`<T>`，必须定义其他类型（例如`<K>`）来实现静态泛型方法；
3. 泛型可以同时定义多种类型，例如`Map<K, V>`。

## 14 Maven基础

