# Java教程-笔记

## 1 Java快速入门

### 1.1 Java简介

#### 1.1.1 安装JDK

1. 设置JAVA_HOME系统环境变量
2. 在系统环境变量Path中添加%JAVA_HOME%\bin\
3. 需要注意的是，现在安装JDK，安装程序会自动创建C:\Program Files\Common Files\Oracle\Java\javapath目录，并在里面存放一系列Java的exe程序，并把这一目录添加到Path最开头去（有的版本会把exe程序放到C:\Windows\System32中去，且C:\Windows\System32本就在Path环境变量中）。因此，我们在cmd命令行中运行java -version其实是调用这一目录下的exe而没有用到上述JAVA_HOME设置。如果想要用到上述JAVA_HOME设置，可以把%JAVA_HOME%\bin\移动到C:\Program Files\Common Files\Oracle\Java\javapath前面去。
4. 如果安装两个JDK版本可以设置两个系统环境变量，比如一个为JAVA_HOME_15另一个为JAVA_HOME_1.8指向各自的安装目录，那么只要在Path中将%JAVA_HOME%\bin\移动到C:\Program Files\Common Files\Oracle\Java\javapath前面，并改变%JAVA_HOME%的值，即可以实现版本切换
5. 上面第4条是在命令行中实现版本切换，如果要在ide比如eclipse中实现版本切换，只需要在Window-Preferences-Java-Installed JREs中添加并选择相应版本的jre，同时在Window-Preferences-Java-Compiler中将“Compiler compliance level”设置为相应版本号，即完成了对当前工作空间的版本切换。

### 1.2 Java程序基础

#### 1.2.1 Java程序基本结构

1. 各种命名的强制规范都是英文字母开头，后接字母，数字和下划线的组合
2. 类名建议规范为每个单词的首字母大写，遇到缩写要全大写。
3. 方法名的建议规范时第一个单词全小写，剩下的单词首字母大写。遇到缩写要全大写。
4. 包名的建议规范是全小写
5. JAVA关键字/数据类型一般都是全小写
6. Java入口程序规定的方法必须是静态方法，方法名必须为`main`，括号内的参数必须是String数组。
7. Java的每一行语句必须以分号结束

#### 1.2.2 变量和数据类型

1. Java只定义了带符号的整型，因此，最高位的bit表示符号位
2. 在Java语言当中，表示数字，没有前缀表示十进制，0b前缀表示二进制，0前缀表示八进制(python当中是0o前缀），0x前缀表示16进制，0e前缀表示科学计数法。同一个数的不同进制的表示是完全相同的，例如`15`=`0xf`＝`0b1111`
3. 对于整形来说，如果是long，在数的最后要加L，short和int不需要。对于浮点数来说，如果是float，要在数的最后加f，double不需要。
4. Java语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要1 bit，但是通常JVM内部会把`boolean`表示为4字节整数。Java是true,false，python是True，Fasle
5. 一个char，用单引号括起来，表示一个unicode字符，占据两个字节。
6. 常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。根据习惯，常量名通常全部大写（建议规范）
7. 在语句块中定义的变量，它有一个作用域，就是从定义处开始，到语句块结束时结束。
8. 引用类型内部存储的是“地址”，指向某个对象在内存的位置

#### 1.2.4 浮点数运算

1. 浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算。
2. 由于很多十进制的小数转换为二进制是无限循环的，因此很多小数浮点数无法精确表示，浮点数运算也就存在误差。由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数
3. 如果一个数没有小数点后的位，但我们想让它是浮点数，就用.0，比如5.0

#### 1.2.5 布尔运算

1. 布尔运算包括比较运算和逻辑运算，前者结果是boolean，后者参与运算的是boolean
2. !=为比较运算符，!为逻辑运算的非，相当于python中的not
3. 布尔运算的一个重要特点是短路运算。如果一个布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果。
4. 三元运算符是通过问号和冒号

#### 1.2.6 字符和字符串

1. 一个char保存一个unicode字符，可以是英文，可以是中文，用单引号括起来。有两种表示方法，一个是单引号括起来一个字符，另一个是单引号括起来'\\uxxxx'的形势，其中xxxx为4个十六进制unicode编码。
2. 想要得到一个char的unicode编码直接将其赋值给int类型的变量即可。
3. 一个字符串可以存储0个到任意个字符，因此存在空字符串
4. 在字符串中，一个双引号内，可以混用字符和\u的unicode编码。String s = "ABC\n\u4e2d\u6587"; // 包含6个字符: A, B, C, 换行符, 中, 文
5. 如果用`+`连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接
6. 多行字符串使用三个双引号，好处是不用写那么多的换行符
7. Java中的字符串类型是不可变的
8. 引用类型的变量可以指向一个空值`null`，它表示不存在，即该变量不指向任何对象。如果只声明不赋值一个引用类型的变量，那么这边变量也是`null`
9. 注意要区分空值`null`和空字符串`""`，空字符串是一个有效的字符串对象，它不等于`null`

#### 1.2.7 数组类型

1. Java数组三种建立方式
2. 数组创建后所有元素初始化为默认值
3. 数组创建后长度不能更改
4. 方括号可以索引数组元素，索引从0开始，方括号也可以修改数组元素
5. 可以用`数组变量.length`获取数组大小
6. 数组中的元素可以是基本类型，可以是引用类型，还可以是自己定义的类型。

### 1.3 流程控制

#### 1.3.1 输入和输出

System.out.println()及其他一系列方法，输入不一定是字符串，也可以是int等其他类型，它会自动转化为字符串然后输出。

#### 1.3.2 if判断

if判断三种形势：

1. 只有if，则if后面条件为true，执行if后面代码块，为false则不执行，跳到if代码块后面执行
2. if...else...，则if后面条件为true，执行if后面代码块，为false则执行else后面代码块
3. if...else if...else if...，按照顺序从上到下判断条件，遇到第一个true的时候执行后面的代码块，其他代码不再执行，即存在逻辑短路。如果全为false，则跳过这一段代码块执行后面的
4. if...else if...else if...else，按照顺序从上到下判断条件，遇到第一个true的时候执行后面的代码块，其他代码不再执行，即存在逻辑短路。如果全为false，则执行else后面代码块
5. 浮点数判断值是否相等用Math.abs(a-b)<0.00001，其他数值类型用==，引用类型用.equals()，引用类型用==的话判断的是是否指向同一对象。我的理解是，==判断的就是值是否相等，但是引用类型内部存储的是内存地址，因此判断地址是否相等本质上判断的是是否指向同一对象。
6. switch旧语法具有穿透效应，不能逻辑短路，如果两个条件相邻且执行同一个语句，第一个条件冒号后面可以不写。switch新语法不具有穿透效应，是逻辑短路的。用->代替:，后面可以跟大括号包起来的代码块，可以用来赋值。在代码块中可以用yield声明返回值。

#### 1.3.6 for循环

由于for循环是先初始化计数器再判断循环条件，因此即使第一次就不满足循环条件，计数器依旧被初始化了。

#### 1.3.7 break和continue

break和continue都是作用于其所在的那一层循环，仅作用于一层。

#### 1.3.8 命令行参数

命令行参数在java程序中以字符串数组的形式存在，但我们在命令行中输入的时候只要字符串,字符串,...这样即可。

## 2 面向对象编程

### 2.1 面向对象基础

#### 2.1.1 方法

1. 在类定义内声明变量，那么这个变量就成为了属性/字段。属性可以在声明的时候直接赋值
2. 在声明变量和方法的时候，在类型前面可以加修饰符表示权限，如public static
3. 调用方法时，必须严格按照定义的类型和顺序传入
4. 基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。
5. java中的修饰符分类:
   - 权限修饰符: private, protected, public，默认不写(即default)
   - 状态修饰符: static, final
   - 抽象修饰符: abstract

#### 2.1.2 构造方法

1. 在java中，属性总要在类中显式的声明，就像在java中变量总要显示声明一样，即使我有给属性赋值的构造方法，也要在构造方法之前先声明，这里声明的是实例属性。如果要声明类属性，需要加关键字static。对比python，python中的实例属性不需要提前声明，可以直接写在构造函数中，如果提前声明了，那么就成为了类属性。在两种语言中，所有属性/变量都可以在声明的时候直接赋值
2. 构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有`void`），调用构造方法，必须用`new`操作符，同时构造方法前面要有public这种表示权限的修饰符。
3. 如果不自己写构造方法，那么编译器会自动给补上空构造方法（其实在空构造方法中还会再补上一个super()，即调用父类构造方法），如果自己写了，那么编译器就不会补了。
4. 实例化的时候先初始化属性，再初始化构造方法，所以如果在声明属性的时候赋值了，构造方法中又赋值了，那么最后会以构造法方法中为准，因为其后执行。
5. 没有在构造方法中初始化字段时，引用类型的字段默认是`null`，数值类型的字段用默认值，`int`类型默认值是`0`，布尔类型默认值是`false`
6. 可以定义多个构造方法，在通过`new`操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分。
7. 作用域越小的局部变量，在它所在作用域中就优先级越高，所以在构造方法中，如果字段名和形参名重名，形参名优先级更高，字段名前面要加this.防止歧义。

#### 2.1.3 方法重载

1. 方法重载(overload)，返回值和函数名相同，但参数不同，编译器通过方法的参数数量、位置和类型自动区分调用哪个方法。
2. 2.1.2节中的定义多个构造函数就是方法重载。

#### 2.1.4 继承

1. 在Java中，没有明确写`extends`的类，编译器会自动加上`extends Object`，同时，所有继承树向上追溯都可以追溯到Object类。
2. Java只允许一个class继承自一个类，但一个类可以被多个类继承。因此，一个类有且仅有一个父类。只有`Object`特殊，它没有父类。
3. 在java中，子类继承父类除了构造函数外的所有属性和方法，因此严禁定义与父类重名的字段，但可以覆写(override)父类方法。
4. 但是一些private的属性和方法无法访问（这里存疑，是继承所有但private无法访问，还是继承非private呢？但是这个疑问并不影响使用）注意，这里的无法访问是说，即使使用类内访问也无法访问，类内访问可以访问子类自己的private但是不能访问父类的private，如果想要访问父类的private，需要使用继承下来的父类的public方法。
5. 子类不会继承父类的构造方法。如果不自己定义构造方法，那么编译器会补一个空构造方法，然后再空构造方法中补一个super()即调用父类构造方法。如果是自己定义构造方法的话，如果不显示调用父类构造方法，那么编译器也会给你自动加super()，显式调用则不会加。因此如果自己定义子类构造方法，第一行必须是父类的构造函数，如果你不写，编译器也会给你自动加super()，这时候如果父类没有空构造方法，就会报错。总而言之，对于一个类来说，第一步，如果没有自己定义构造方法，编译器会补一个空构造方法；第二步，对于所有构造方法（包括上一步编译器自己补的空构造方法）来说，如果没有在第一行调用父类构造方法，编译器会补一个super()。
6. 向上转型(upcasting)一定是成功的，但向下转型(downcasting)不一定能成功

#### 2.1.X 权限修饰符的作用

1. 见https://blog.csdn.net/aimeimeits/article/details/54136219
2. java当中的权限修饰符分为两级，一级是修饰类的，一级是修饰成员（即属性和方法）的
3. 第一级修饰类的只有public和不写，即没有显式修饰符（即package-private或者说default）两种，代表包外是否可见
4. 第二类修饰符有四种，按照权限由大到小分为public>protected>default(即不写)>private，权限关系见上面的博文
5. 当我们在java程序中调用某个类及其成员，整个判断过程如下：
   - 如果类名简写，即前面没有包名，会去当前包，import的类以及java.lang中去找这个类的完整名，即包名.类名，如果使用完整类名，则已经得到完整类名直接进行下一步
   - 在classpath中找这个类的路径，eclipse默认是bin以及import类的路径以及java核心类路径（这里面存在查找顺序与逻辑短路），其中import类的路径会在eclipse的library中查找，library中存放的是类的文件路径。
   - 如果这个类是public类，则直接跳转下一步。如果这个类是package-private，且与本程序在一个包中，那么跳转下一步。如果这个类是package-private，且与本程序不在一个包中，那么此类包外不可见，无法调用。
   - 到这一步，这个类是可用的，但类内成员是否可用要根据第二类修饰符的权限进行判别，见上面博客。
   - 继承之后，如果子类对某一成员依旧具有访问权限，那么我们就认为这个成员的权限修饰符和父类一样，如果子类无法访问这个成员，那么我们就可以直接当作这一成员不存在了。
   - 具体还是存在很多细节，比如包权限，子类在包外，子类的子类回到包内，这种情况我的理解是，不考虑中间的子类，直接把孙类和父类放在一起看，反正孙类也是父类的子类，而且父类的方法它全部继承了，涉及权限问题就按孙类是父类的子类然后按表来。这只是猜测，准不准我也不知道。

#### 2.1.5 多态

1. 重载(overload)是只函数名，返回类型相同，但参数不同，本质是两个不同的函数，作用是方便多样化调用，每一个重载的函数都有被调用的可能。覆写/重写(override)是指函数名，返回类型，参数都相同。一般用在子类上，重写父类方法，引出多态。
2. 方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。
3. 子类覆写父类方法，在调用的时候无论变量类型是子类还是父类，只要指向的是子类实例，则调用子类覆写后的方法。因为ava的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。
4. java中的多态即把子类实例传入父类变量，从而只用对父类变量编写程序，具体运行效果依赖传入的子类实例，因为子类覆写了父类方法。子类覆写父类方法是多态的关键。
5. final修饰变量（包括类中的属性），则无法被重新赋值，修饰方法，则无法被覆写，修饰类，则这个类无法被继承，见：https://www.cnblogs.com/tanshaoshenghao/p/10908771.html



#### 2.1.8 静态字段和静态方法

1. 静态字段和方法的修饰符为static，所谓静态字段和静态方法即为类字段和类方法。
2. 通过实例可以访问和修改静态字段，可以调用静态方法，但本质都是编译器先把实例名转换成为类名再调用。
3. 静态方法类似于其他语言中的函数，不属于实例，因此内部无法调用this变量，也无法访问实例字段，只能访问静态字段

### 2.2 异常处理

### 2.2.1 Java的异常

1. 异常会出现在两个时候，编译的时候和运行的时候。
2. 必须捕获的异常是指在调用时必须手动用try catch捕获，或者向上一层抛出（即使运行不会出错），如果不捕获/向上一层抛出，那么即使整个运行本身不会出错也会编译失败；不必须捕获的，不捕获也不会编译失败，可以看实际情况确定是否捕获，如果不捕获，那么在运行过程中遇到异常会一层层向上抛出（不需要写throw)。
3. try catch语句使得当发生预期异常的时候程序不会失败退出，而是按照预先给的方案运行下去，即异常被捕获住了。
4. 在方法定义时可以在参数括号后面，函数体花括号前面使用`throws Xxx(异常类型)`表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。
5. 在调用方法的方法中也可以用`throws Xxx(异常类型)`，作用是异常可以在这一层被检查但不在这一层被捕获，而是抛到上一层，由上一层负责捕获。即对于一个Checked Exception来说， must be caught or declared to be thrown。由此可见，`main()`方法也是最后捕获`Exception`的机会。
6. 可以直接把`main()`方法定义为`throws Exception`，在内部就无需捕获了，异常会被直接抛给调用者/程序员。代价就是一旦发生异常，程序会立刻退出。也就是说在这个时候，编译的异常规范被满足，编译时不会出错；但运行的时候一旦出错，没有try catch的异常处理方案，会直接报错退出。

#### 2.2.2 捕获异常

1. 如果方法声明了throw异常抛出，那么try后面可以不加catch直接finally，因为这时候异常可以不被捕获而是直接抛出。

#### 2.2.3 抛出异常

