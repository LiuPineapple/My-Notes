# Java教程-笔记

## 1 JAVA快速入门

### 1.2 JAVA程序基础

#### 1.2.1 JAVA程序基本结构

1. 各种命名的强制规范都是英文字母开头，后接字母，数字和下划线的组合
2. 类名建议规范为每个单词的首字母大写，遇到缩写要全大写。
3. 方法名的建议规范时第一个单词全小写，剩下的单词首字母大写。遇到缩写要全大写。
4. 包名的建议规范是全小写
5. JAVA关键字一般都是全小写

## 2 面向对象编程

### 2.1 面向对象基础

#### 2.1.1 方法

1. 在类定义内声明变量，那么这个变量就成为了属性/字段。属性可以在声明的时候直接赋值
2. 在声明变量和方法的时候，在类型前面可以加修饰符表示权限，如public static
3. 调用方法时，必须严格按照定义的类型和顺序传入
4. 基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。
5. java中的修饰符分类:
   - 权限修饰符: private, protected, public，默认不写(即default)
   - 状态修饰符: static, final
   - 抽象修饰符: abstract

#### 2.1.2 构造方法

1. 在java中，属性总要在类中显式的声明，就像在java中变量总要显示声明一样，即使我有给属性赋值的构造方法，也要在构造方法之前先声明，这里声明的是实例属性。如果要声明类属性，需要加关键字static。对比python，python中的实例属性不需要提前声明，可以直接写在构造函数中，如果提前声明了，那么就成为了类属性。在两种语言中，所有属性/变量都可以在声明的时候直接赋值
2. 构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有`void`），调用构造方法，必须用`new`操作符，同时构造方法前面要有public这种表示权限的修饰符。
3. 如果不自己写构造方法，那么编译器会自动给补上空构造方法（其实在空构造方法中还会再补上一个super()，即调用父类构造方法），如果自己写了，那么编译器就不会补了。
4. 实例化的时候先初始化属性，再初始化构造方法，所以如果在声明属性的时候赋值了，构造方法中又赋值了，那么最后会以构造法方法中为准，因为其后执行。
5. 没有在构造方法中初始化字段时，引用类型的字段默认是`null`，数值类型的字段用默认值，`int`类型默认值是`0`，布尔类型默认值是`false`
6. 可以定义多个构造方法，在通过`new`操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分。
7. 作用域越小的局部变量，在它所在作用域中就优先级越高，所以在构造方法中，如果字段名和形参名重名，形参名优先级更高，字段名前面要加this.防止歧义。

#### 2.1.3 方法重载

1. 方法重载，返回值和函数名相同，但参数不同，编译器通过方法的参数数量、位置和类型自动区分调用哪个方法。
2. 2.1.2节中的定义多个构造函数就是方法重载。

#### 2.1.4 继承

1. 在Java中，没有明确写`extends`的类，编译器会自动加上`extends Object`，同时，所有继承树向上追溯都可以追溯到Object类。
2. Java只允许一个class继承自一个类，但一个类可以被多个类继承。因此，一个类有且仅有一个父类。只有`Object`特殊，它没有父类。
3. 在java中，子类继承父类除了构造函数外的所有属性和方法，因此严禁定义与父类重名的字段，但可以覆写父类方法。
4. 但是一些private的属性和方法无法访问（这里存疑，是继承所有但private无法访问，还是继承非private呢？但是这个疑问并不影响使用）注意，这里的无法访问是说，即使使用类内访问也无法访问，类内访问可以访问子类自己的private但是不能访问父类的private，如果想要访问父类的private，需要使用继承下来的父类的public方法。
5. 子类不会继承父类的构造方法。如果不自己定义构造方法，那么编译器会补一个空构造方法，然后再空构造方法中补一个super()即调用父类构造方法。如果是自己定义构造方法的话，如果不显示调用父类构造方法，那么编译器也会给你自动加super()，显式调用则不会加。因此如果自己定义子类构造方法，第一行必须是父类的构造函数，如果你不写，编译器也会给你自动加super()，这时候如果父类没有空构造方法，就会报错。总而言之，对于一个类来说，第一步，如果没有自己定义构造方法，编译器会补一个空构造方法；第二步，对于所有构造方法（包括上一步编译器自己补的空构造方法）来说，如果没有在第一行调用父类构造方法，编译器会补一个super()。
6. 进度到阻止继承这里了。

#### 2.1.X 权限修饰符的作用

1. 见https://blog.csdn.net/aimeimeits/article/details/54136219
2. java当中的权限修饰符分为两级，一级是修饰类的，一级是修饰成员（即属性和方法）的
3. 第一级修饰类的只有public和不写，即没有显式修饰符（即package-private或者说default）两种，代表包外是否可见
4. 第二类修饰符有四种，按照权限由大到小分为public>protected>default(即不写)>private，权限关系见上面的博文
5. 当我们在java程序中调用某个类及其成员，整个判断过程如下：
   - 如果类名简写，即前面没有包名，会去当前包，import的类以及java.lang中去找这个类的完整名，即包名.类名，如果使用完整类名，则已经得到完整类名直接进行下一步
   - 在classpath中找这个类的路径，eclipse默认是bin以及import类的路径以及java核心类路径（这里面存在查找顺序与逻辑短路），其中import类的路径会在eclipse的library中查找，library中存放的是类的文件路径。
   - 如果这个类是public类，则直接跳转下一步。如果这个类是package-private，且与本程序在一个包中，那么跳转下一步。如果这个类是package-private，且与本程序不在一个包中，那么此类包外不可见，无法调用。
   - 到这一步，这个类是可用的，但类内成员是否可用要根据第二类修饰符的权限进行判别，见上面博客。
   - 继承之后，如果子类对某一成员依旧具有访问权限，那么我们就认为这个成员的权限修饰符和父类一样，如果子类无法访问这个成员，那么我们就可以直接当作这一成员不存在了。
   - 具体还是存在很多细节，比如包权限，子类在包外，子类的子类回到包内，这种情况我的理解是，不考虑中间的子类，直接把孙类和父类放在一起看，反正孙类也是父类的子类，而且父类的方法它全部继承了，涉及权限问题就按孙类是父类的子类然后按表来。这只是猜测，准不准我也不知道。

#### 2.1.5 多态

1. 重载(overload)是只函数名，返回类型相同，但参数不同，作用是方便多样化调用，每一个重载的函数都有被调用的可能。覆写/重写(override)是指函数名，返回类型，参数都相同。一般用在子类上，重写父类方法，引出多态



#### 2.1.8 静态字段和静态方法

1. 静态字段和方法的修饰符为static，所谓静态字段和静态方法即为类字段和类方法。
2. 通过实例可以访问和修改静态字段，可以调用静态方法，但本质都是编译器先把实例名转换成为类名再调用。
3. 静态方法类似于其他语言中的函数，不属于实例，因此内部无法调用this变量，也无法访问实例字段，只能访问静态字段
4. 